# 200.岛屿数量

## 题干

```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

};
```

## DFS

### 思路

1. 定义`dfs`函数

2. 两层循环遍历，找到网格中的“1”。

3. 以当前找到的“1”开始，朝四个方向继续访问，一路递归，把所有的邻近的“1”全部变成0，直到遇到“0”或者边界。

### 代码

```javascript
var numIslands = function (grid) {
    //先获取网格有多少行多少列
	const row = grid.length,
          column = grid[0].length;
    //定义dfs函数
    const dfs = function(i,j){
        //遇到“0”或者边界就return
        if(i<0 || i>=row || j<0 || j>=column || grid[i][j] === '0') return;
        grid[i][j] = '0';	//做标记
        dfs(i+1,j);
        dfs(i,j+1);
        dfs(i-1,j);
        dfs(i,j-1);
    }
    let res = 0;
    for(let i = 0;i < row;i++){
        for(let j = 0;j < column;j++){
            if(grid[i][j] === '1'){
                dfs(i,j);
                res++;
            }
        }
    }
    return res;
};
```

## BFS

### 思路

1. BFS需要我们维持一个队列，遇到“1”则让该坐标入列，然后判断四个方向是否为“0”、“1”或者出界。
2. 遍历四个方向，此时有四个坐标，如果是“0”或者出界，则该坐标不需要入列，如果是“1”，则将其转换为0之后再把改坐标入列。

### 代码

```javascript
const numIslands = (grid) => {
  let res = 0;
  let queue = [];
  let bfs = function(queue, grid) {
  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]
 	 while (queue.length) {
    	let cur = queue.shift();
    	for (const dir of dirs) {
     	 let x = cur[0] + dir[0]
     	 let y = cur[1] + dir[1]
     	 if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] !== '1') {
       	 continue;
     	 }
     	 grid[x][y] = '0';
      	 queue.push([x, y]);
    }
  }
}
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] === '1') {
        res++;
        grid[i][j] = '0';// 做标记，避免重复遍历
        queue.push([i, j]);
        bfs(queue, grid);//遇到“1”则让该坐标入列
      }
    }
  }
  return res
}

```

## 总结

200.岛屿数量，DFS和BFS的两种解法有许多相像之处，比如遇到“1”先变成“0”再开始遍历。

也有不同之处，比如DFS需在四个方向递归，就像二叉树的前序遍历，需要递归；而BFS需要维持一个队列，就像二叉树的层序遍历。
