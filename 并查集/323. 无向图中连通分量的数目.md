# 323. 无向图中连通分量的数目 

## 题干

### 题目描述

给定编号从 `0` 到 `n-1` 的 `n` 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。

### 示例

```text
示例 1:

输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4 

输出: 2
```

示例 2:

```text
输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

输出:  1
```

注意:

你可以假设在 edges 中不会出现重复的边。而且由于所以的边都是无向边，[0, 1] 与 [1, 0] 相同，所以它们不会同时在 edges 中出现。

## 题解

### 思路

1. 定义一个并查集类`UnionFind`。
2. 把每条边按给出的`edge`连起来。
3. 一旦两个节点连起来了，他们的`parent`的值就相同了。
4. 因此最后遍历所有节点，看看有多少个`parent`的值即是连通分量的数目。

### 代码

```javascript
function countComponents(n,edges) {
	class UnionFind {
		constructor(count) {
			this.parent=new Array(count);
			for(let i = 0;i<count;i++) {
					this.parent[i]=i;
				}
		}
		find(p) {
			if(this.parent[p]===p) {
					return p;
			}
			this.parent[p]=this.find(this.parent[p]);
			return this.parent[p];
		}
		union(p,q) {
			let i=this.find(p);
			let j=this.find(q);
			if(i!==j) {
					this.parent[i]=j
			}
		}
		isConnected(p,q) {
			return this.find(p)===this.find(q)
		}
	}
	let res = 0;
	let unionFind = new UnionFind(n);
	for(let edge of edges) {
			unionFind.union(edge[0],edge[1]);
	}
	for(let i = 0; i<n;i++) {
			if(unionFind.find(i)===i) {
					res++;
			}
	}
	return res;
}
```

